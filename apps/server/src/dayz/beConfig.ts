/**
 * dayz/beConfig.ts
 *
 * Reads/writes BattlEye RCon config files.
 *
 * Files involved:
 * - BEServer_x64.cfg (static config)
 * - BEServer_x64_active_<CODE>.cfg (runtime config created/renamed when RCon is enabled)
 *
 * The panel uses this to:
 * - Read the RCon password / port (for connecting)
 * - Let you edit these values safely from the UI
 */

import fs from 'node:fs/promises';
import path from 'node:path';
import { ensureDir, fileExists } from '../storage/jsonStore.js';

export type BattleyeConfig = {
  filePath: string;
  isActive: boolean;
  entries: Record<string, string>;
  raw: string;
};

/**
 * Find the most relevant BattlEye config file in a directory.
 *
 * Preference:
 * 1) BEServer_x64_active_*.cfg (if it exists)
 * 2) BEServer_x64.cfg
 */
export async function findBattleyeCfgFile(battleyeDir: string): Promise<{ filePath: string; isActive: boolean }> {
  const files = await fs.readdir(battleyeDir).catch(() => [] as string[]);
  const active = files.find((f) => /^BEServer_x64_active_.*\.cfg$/i.test(f));
  if (active) {
    return { filePath: path.join(battleyeDir, active), isActive: true };
  }

  const base = files.find((f) => /^BEServer_x64\.cfg$/i.test(f));
  if (base) {
    return { filePath: path.join(battleyeDir, base), isActive: false };
  }

  // If not found, still return the canonical path so the UI can create it.
  return { filePath: path.join(battleyeDir, 'BEServer_x64.cfg'), isActive: false };
}

/**
 * Parse a BEServer_x64.cfg style file into a key-value map.
 *
 * Typical lines:
 *   RConPassword myPassword
 *   RConPort 2305
 *   RestrictRCon 0
 */
export function parseBattleyeCfg(raw: string): Record<string, string> {
  const map: Record<string, string> = {};

  const lines = raw.replace(/\r\n/g, '\n').split('\n');
  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed) continue;

    // Ignore comment styles (just in case)
    if (trimmed.startsWith('//') || trimmed.startsWith('#') || trimmed.startsWith(';')) continue;

    const m = trimmed.match(/^([A-Za-z0-9_]+)\s+(.*)$/);
    if (!m) continue;

    const key = m[1];
    const value = m[2].trim();
    map[key] = value;
  }

  return map;
}

export async function readBattleyeConfig(battleyeDir: string): Promise<BattleyeConfig> {
  const { filePath, isActive } = await findBattleyeCfgFile(battleyeDir);

  let raw = '';
  if (await fileExists(filePath)) {
    raw = await fs.readFile(filePath, 'utf8');
  }

  return {
    filePath,
    isActive,
    raw,
    entries: parseBattleyeCfg(raw)
  };
}

/**
 * Writes a BattlEye config file.
 *
 * Important behavior:
 * - We rewrite the whole file for deterministic output.
 * - We keep a small header so it stays readable.
 */
export async function writeBattleyeConfig(filePath: string, entries: Record<string, string>): Promise<void> {
  await ensureDir(path.dirname(filePath));

  const lines: string[] = [];
  lines.push('// Generated by DayZ Local Panel');
  lines.push('// NOTE: If an active config file exists (BEServer_x64_active_*.cfg),');
  lines.push('// you may need to delete it to force BattlEye to re-read the base config.');
  lines.push('');

  // Write keys in a stable order
  const order = ['RConPassword', 'RConPort', 'RestrictRCon', 'RConIP', 'LogFile'];
  const keys = Array.from(new Set([...order, ...Object.keys(entries)])).filter((k) => entries[k] !== undefined);

  for (const k of keys) {
    lines.push(`${k} ${entries[k]}`);
  }

  await fs.writeFile(filePath, lines.join('\r\n') + '\r\n', 'utf8');
}

/**
 * Deletes any BEServer_x64_active_*.cfg file.
 *
 * Why:
 * - Some hosts and tools note that BattlEye creates an active file at runtime.
 * - If you change the password in the base file, it may keep using the active file until that is removed.
 */
export async function deleteActiveBattleyeCfg(battleyeDir: string): Promise<{ deleted: string[] }> {
  const files = await fs.readdir(battleyeDir).catch(() => [] as string[]);
  const activeFiles = files.filter((f) => /^BEServer_x64_active_.*\.cfg$/i.test(f));

  const deleted: string[] = [];
  for (const f of activeFiles) {
    const p = path.join(battleyeDir, f);
    await fs.rm(p, { force: true });
    deleted.push(p);
  }

  return { deleted };
}
