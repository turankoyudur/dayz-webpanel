import { EventEmitter } from 'events';
import { UdpTransport } from './transport/UdpTransport.js';
import { TcpTransport } from './transport/TcpTransport.js';
import { PacketBuilder } from './protocol/PacketBuilder.js';
import { PacketParser } from './protocol/PacketParser.js';
import { PacketType, DEFAULTS } from './protocol/Constants.js';
import { PacketAssembler } from './protocol/PacketAssembler.js';
import { RconError, RconErrorCode } from './RconError.js';
export class BattleNode extends EventEmitter {
    transport;
    config;
    sequence = 0;
    pendingCommands = new Map();
    keepAliveTimer = null;
    connected = false;
    loginPromise = null;
    startTime = 0;
    packetAssembler;
    commandQueue = [];
    isProcessingQueue = false;
    stats = {
        commandsSent: 0,
        commandsFailed: 0,
        packetsLost: 0,
        averageLatency: 0,
        uptime: 0,
        isConnected: false
    };
    constructor(config) {
        super();
        this.config = {
            ip: config.ip,
            port: config.port,
            rconPassword: config.rconPassword ?? '',
            timeout: config.timeout ?? DEFAULTS.TIMEOUT,
            transportType: config.transportType ?? 'udp',
            keepAliveInterval: config.keepAliveInterval ?? DEFAULTS.KEEPALIVE_INTERVAL,
            commandTimeout: config.commandTimeout ?? 5000,
            maxRetries: config.maxRetries ?? 3,
            retryDelay: config.retryDelay ?? 1000,
            logLevel: config.logLevel ?? 'info',
            ...(config.logger ? { logger: config.logger } : {})
        };
        this.packetAssembler = new PacketAssembler(this.config.commandTimeout);
        if (this.config.transportType === 'tcp') {
            this.transport = new TcpTransport(this.config);
        }
        else {
            this.transport = new UdpTransport(this.config);
        }
        this.setupTransport();
    }
    setupTransport() {
        this.transport.on('message', (msg) => this.handleMessage(msg));
        this.transport.on('error', (err) => {
            this.log('error', 'Transport error', { error: err.message });
            this.emit('error', new RconError(err.message, RconErrorCode.SOCKET_ERROR));
        });
        this.transport.on('close', () => {
            if (this.connected) {
                this.log('warn', 'Connection closed unexpectedly');
                this.disconnect();
            }
        });
        this.transport.on('connected', () => {
            this.log('debug', 'Transport connected');
        });
    }
    log(level, message, meta) {
        if (!this.config.logger)
            return;
        const levels = ['debug', 'info', 'warn', 'error'];
        if (levels.indexOf(level) >= levels.indexOf(this.config.logLevel)) {
            this.config.logger(level, message, meta);
        }
    }
    getStats() {
        return {
            ...this.stats,
            uptime: this.connected ? Date.now() - this.startTime : 0,
            isConnected: this.connected
        };
    }
    async login() {
        if (this.connected)
            return;
        this.log('info', `Connecting to ${this.config.ip}:${this.config.port}...`);
        await this.transport.connect();
        return new Promise((resolve, reject) => {
            this.loginPromise = { resolve, reject };
            const packet = PacketBuilder.buildLogin(this.config.rconPassword);
            this.transport.send(packet).catch((err) => {
                this.loginPromise = null;
                reject(new RconError(err.message, RconErrorCode.SOCKET_ERROR));
            });
            setTimeout(() => {
                if (this.loginPromise) {
                    this.loginPromise.reject(new RconError('Login timeout', RconErrorCode.AUTHENTICATION_FAILED));
                    this.loginPromise = null;
                }
            }, this.config.timeout);
        });
    }
    async sendCommand(command) {
        if (!this.connected)
            throw new RconError('Not connected', RconErrorCode.DISCONNECTED);
        return new Promise((resolve, reject) => {
            const task = async () => {
                try {
                    const result = await this.executeCommandWithRetry(command);
                    resolve(result);
                }
                catch (err) {
                    if (err instanceof Error)
                        reject(err);
                    else
                        reject(new Error(String(err)));
                }
            };
            this.commandQueue.push(task);
            this.processQueue();
        });
    }
    async processQueue() {
        if (this.isProcessingQueue)
            return;
        this.isProcessingQueue = true;
        while (this.commandQueue.length > 0) {
            const task = this.commandQueue.shift();
            if (task) {
                try {
                    await task();
                }
                catch (err) {
                    this.log('error', 'Queue processing error', err);
                }
            }
        }
        this.isProcessingQueue = false;
    }
    async executeCommandWithRetry(command) {
        let lastError = null;
        for (let attempt = 0; attempt <= this.config.maxRetries; attempt++) {
            try {
                if (attempt > 0) {
                    const delay = this.config.retryDelay * Math.pow(2, attempt - 1);
                    this.log('debug', `Retrying command '${command}' (Attempt ${attempt + 1}/${this.config.maxRetries + 1}) in ${delay}ms`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
                return await this.sendSingleCommand(command);
            }
            catch (err) {
                lastError = err instanceof Error ? err : new Error(String(err));
                this.stats.commandsFailed++;
            }
        }
        throw lastError ?? new RconError('Command failed after retries', RconErrorCode.COMMAND_TIMEOUT);
    }
    sendSingleCommand(command) {
        return new Promise((resolve, reject) => {
            const seq = this.nextSequence();
            const packet = PacketBuilder.buildCommand(seq, command);
            const sentAt = Date.now();
            this.stats.commandsSent++;
            const timer = setTimeout(() => {
                if (this.pendingCommands.has(seq)) {
                    this.pendingCommands.delete(seq);
                    this.stats.packetsLost++;
                    reject(new RconError(`Command timed out`, RconErrorCode.COMMAND_TIMEOUT));
                }
            }, this.config.commandTimeout);
            this.pendingCommands.set(seq, {
                resolve,
                reject,
                sentAt,
                command,
                timer
            });
            this.transport.send(packet).catch((err) => {
                clearTimeout(timer);
                this.pendingCommands.delete(seq);
                reject(new RconError(err.message, RconErrorCode.SOCKET_ERROR));
            });
        });
    }
    disconnect() {
        this.log('info', 'Disconnecting...');
        this.stopKeepAlive();
        for (const [seq, cmd] of this.pendingCommands) {
            clearTimeout(cmd.timer);
            cmd.reject(new RconError('Client disconnected', RconErrorCode.DISCONNECTED));
        }
        this.pendingCommands.clear();
        this.packetAssembler.clear();
        this.transport.close();
        this.connected = false;
        this.startTime = 0;
        this.stats.isConnected = false;
        this.emit('disconnected');
    }
    handleMessage(buffer) {
        this.log('debug', `Received packet (${buffer.length} bytes)`, { hex: buffer.toString('hex') });
        const result = PacketParser.parse(buffer);
        if (!result.isValid) {
            this.log('warn', 'Invalid packet received', result.error);
            return;
        }
        this.log('debug', `Packet parsed successfully, type: ${result.type}`);
        switch (result.type) {
            case PacketType.Login:
                this.handleLoginResponse(result.body);
                break;
            case PacketType.Command:
                this.handleCommandResponse(result.body);
                break;
            case PacketType.Message:
                this.handleServerMessage(result.body);
                break;
        }
    }
    handleLoginResponse(body) {
        const firstByte = body[0];
        const success = body.length > 0 && firstByte === 0x01;
        if (this.loginPromise) {
            if (success) {
                this.connected = true;
                this.stats.isConnected = true;
                this.startTime = Date.now();
                this.startKeepAlive();
                this.emit('connected');
                this.loginPromise.resolve();
            }
            else {
                this.loginPromise.reject(new RconError('Invalid RCON password', RconErrorCode.AUTHENTICATION_FAILED));
            }
            this.loginPromise = null;
        }
        this.emit('loginResponse', success);
    }
    handleCommandResponse(body) {
        if (body.length < 1)
            return;
        const seq = body[0];
        if (seq === undefined)
            return;
        if (!this.pendingCommands.has(seq)) {
            return;
        }
        const cmd = this.pendingCommands.get(seq);
        if (!cmd)
            return;
        let payload = body;
        let isComplete = true;
        if (PacketParser.isMultipart(body)) {
            const assembled = this.packetAssembler.handlePart(body);
            if (assembled) {
                payload = assembled;
                isComplete = true;
            }
            else {
                isComplete = false;
            }
        }
        else {
            payload = body.subarray(1);
        }
        if (isComplete) {
            const latency = Date.now() - cmd.sentAt;
            this.updateLatencyStats(latency);
            this.pendingCommands.delete(seq);
            clearTimeout(cmd.timer);
            cmd.resolve(payload.toString('utf8'));
        }
    }
    updateLatencyStats(latency) {
        if (this.stats.averageLatency === 0) {
            this.stats.averageLatency = latency;
        }
        else {
            this.stats.averageLatency = Math.floor(this.stats.averageLatency * 0.9 + latency * 0.1);
        }
    }
    handleServerMessage(body) {
        if (body.length < 1)
            return;
        const seq = body[0];
        if (seq === undefined)
            return;
        const msg = body.subarray(1).toString('utf8');
        const ack = PacketBuilder.buildAcknowledge(seq);
        this.transport.send(ack).catch((err) => {
            this.log('error', 'Failed to send ACK', err);
        });
        this.emit('message', msg);
    }
    nextSequence() {
        const s = this.sequence;
        this.sequence = (this.sequence + 1) % 256;
        return s;
    }
    startKeepAlive() {
        this.stopKeepAlive();
        this.keepAliveTimer = setInterval(() => {
            if (!this.connected)
                return;
            const seq = this.nextSequence();
            const packet = PacketBuilder.buildKeepAlive(seq);
            this.transport.send(packet).catch(() => { });
        }, this.config.keepAliveInterval);
    }
    stopKeepAlive() {
        if (this.keepAliveTimer) {
            clearInterval(this.keepAliveTimer);
            this.keepAliveTimer = null;
        }
    }
    async getCommands() { return this.sendCommand('commands'); }
    async getVersion() { return this.sendCommand('version'); }
    async getPlayers() { return this.sendCommand('players'); }
    async getBans() { return this.sendCommand('bans'); }
    async getAdmins() { return this.sendCommand('admins'); }
    async kick(playerId, reason = '') { return this.sendCommand(`kick ${playerId} ${reason}`.trim()); }
    async ban(playerId, minutes = 0, reason = '') { return this.sendCommand(`ban ${playerId} ${minutes} ${reason}`.trim()); }
    async addBan(identifier, minutes = 0, reason = '') { return this.sendCommand(`addBan ${identifier} ${minutes} ${reason}`.trim()); }
    async removeBan(banId) { return this.sendCommand(`removeBan ${banId}`); }
    async writeBans() { return this.sendCommand('writeBans'); }
    async loadBans() { return this.sendCommand('loadBans'); }
    async say(message, playerId = -1) { return this.sendCommand(`say ${playerId} ${message}`); }
}
//# sourceMappingURL=BattleNode.js.map