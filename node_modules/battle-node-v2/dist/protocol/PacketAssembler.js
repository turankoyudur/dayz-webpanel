import { PacketParser } from './PacketParser.js';
export class PacketAssembler {
    assemblyMap = new Map();
    timeoutMs;
    constructor(timeoutMs = 3000) {
        this.timeoutMs = timeoutMs;
    }
    handlePart(body) {
        const header = PacketParser.parseMultipartHeader(body);
        const { sequence, total, index, data } = header;
        let entry = this.assemblyMap.get(sequence);
        if (!entry) {
            const timer = setTimeout(() => {
                this.cleanup(sequence);
            }, this.timeoutMs);
            entry = {
                sequence,
                total,
                parts: new Array(total),
                timer,
                resolve: () => { },
                lastActivity: Date.now()
            };
            this.assemblyMap.set(sequence, entry);
        }
        else {
            entry.lastActivity = Date.now();
            entry.timer.refresh();
        }
        if (index < entry.parts.length) {
            entry.parts[index] = data;
        }
        if (this.isComplete(entry)) {
            const result = this.assemble(entry);
            this.cleanup(sequence);
            return result;
        }
        return null;
    }
    isComplete(entry) {
        for (let i = 0; i < entry.total; i++) {
            if (entry.parts[i] === undefined) {
                return false;
            }
        }
        return true;
    }
    assemble(entry) {
        const validParts = entry.parts.filter((p) => p !== undefined);
        return Buffer.concat(validParts);
    }
    cleanup(sequence) {
        const entry = this.assemblyMap.get(sequence);
        if (entry) {
            clearTimeout(entry.timer);
            this.assemblyMap.delete(sequence);
        }
    }
    clear() {
        for (const [seq, entry] of this.assemblyMap) {
            clearTimeout(entry.timer);
        }
        this.assemblyMap.clear();
    }
}
//# sourceMappingURL=PacketAssembler.js.map